transport.type: local
http.type: ssl_netty4

cluster.name: elasticsearch
#http.bind_host: _eth0:ipv4_
#network.host: _eth0:ipv4_

readonlyrest:
    # (De)activate plugin
    enable: true

    ssl:
      enable: false
      keystore_file: "/me/elasticsearch-readonlyrest-plugin-5.x/src/test/eshome/plugins/readonlyrest/keystore.jks"
      keystore_pass: readonlyrest
      key_pass: readonlyrest

    # HTTP response body in case of forbidden request.
    # If this is null or omitted, the name of the first violated access control rule is returned (useful for debugging!)
    response_if_req_forbidden: <h1>Forbidden</h1>

    # Default policy is to forbid everything, so let's define a whitelist
    access_control_rules:

    - name: "::LOGSTASH::"
      auth_key: logstash:logstash
      type: allow
      actions: ["indices:data/read/*","indices:data/write/*","indices:admin/template/*","indices:admin/create"]
      indices: ["logstash-*"]

    - name: "::KIBANA-SRV::"
      auth_key: kibana:kibana
      type: allow

    - name: "::RO DEVELOPER::"
      auth_key: ro:dev
      type: allow
      kibana_access: ro
      indices: [ ".kibana", ".kibana-devnull", "logstash-*"]

    - name: "::RW DEVELOPER::"
      auth_key: rw:dev
      type: allow
      kibana_access: rw
      indices: [".kibana", ".kibana-devnull", "logstash-*"]

    - name: "::ADMIN::"
      auth_key: admin:dev
      type: allow
      kibana_access: admin
      indices: [ ".kibana", ".readonlyrest", ".kibana-devnull", "logstash-*"]

    - name: "::PUBLIC SEARCH::"
      type: allow
      indices: ["public"]
      actions: ["indices:data/read/*"]

# TODO: remove and document new features

    - name: "::Tweets::"
      type: allow
      methods: GET
      indices: ["twitter"]
      proxy_auth:
        - proxy_auth_config: "proxy1"
          users: ["*"]
      provider_roles_authorization:
        - user_role_provider: "RolesService"
          roles: ["role3"]

    - name: "::Facebook posts::"
      type: allow
      methods: GET
      indices: ["facebook"]
      proxy_auth:
        - proxy_auth_config: "proxy1"
          users: ["*"]
      provider_roles_authorization:
        - user_role_provider: "RolesService"
          roles: ["role1"]

    proxy_auth_configs:

    - name: "proxy1"
      user_id_header: "X-Auth-Token"

    user_role_providers:

    - name: RolesService
      role_endpoint: "http://localhost:8080/roles"
      auth_token_name: "token"
      auth_token_passed_as: QUERY_PARAM                        # HEADER OR QUERY_PARAM
      response_roles_json_path: "$..roles[?(@.name)].name"
